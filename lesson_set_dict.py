# # # Завдання до уроку на тему "set() | dict()"

# # Множина
# # new_set = set()
# # new_set2 = {1, 5, 2}

# # Словник
# # new_dict = {}
# # new_dict2 = {"key": "value", "key2": "value2"}

# # ------------------------------------------------------------
# # Початковий рівень
# # -------
# # # 1.Створіть словник зі списками добрих справ на сьогодні і на завтра. Надрукуйте із словника добрі справи, які плануєш зробити сьогодні і взавтра.

# # def task1():
# #     to_do = {
# #         "today": ["read", "clean", "walk the dog"],
# #         "tomorrow": ["read", "call my mom"]
# #     } 

# #     # print(to_do)
# #     print("To do for today:")
# #     for item in to_do["today"]:
# #         print("-", item)

# #     print("To do for tomorrow:")
# #     for item in to_do["tomorrow"]:
# #         print("-", item)


# # -------------------------------------------------------------------------------------
# # # 2.Припустимо, що у нас є словник, в якому ключі є ідентифікаторами, а значення – іменами користувачів. Напишіть програму, яка виводить життєве повідомлення користувача на основі його ідентифікатора. Якщо ідентифікатор відсутній у словнику, виводиться вітання для всіх користувачів.

# # Вхідні дані:

# # 232
# # 550
# # 190
# # 500
# # Вихідні дані:

# # Hi, Alice!
# # Hi, Bob!
# # Hi, Jack!
# # Hi, to all!


# # def task2():
# #     users = {
# #         232: "Alice",
# #         550: "Bob",
# #         190: "Jack"
# #     }

# #     user_id = int(input("Your id: "))

# #     if user_id in users:
# #         print(f"Hi, {users[user_id]}!")
# #     else:
# #         print("Hi, to all!")



# # ------------------------------------------------------------------------------
# # 3.Напишіть програму для сортування за зростанням (за алфавітом) словника за ключами. Словник зберігає пари ключ-значення у вигляді «назви фільму: рік релізу». Інформація виводиться як у вихідних даних: сортування має бути проведено за назвами фільмів.

# Вихідні дані:

# ('Avengers: Endgame', 2019) ('Guardians of the Galaxy', 2014) ('Iron Man', 2008) ('Thor', 2011)

# films = {
#     'Avengers: Endgame': 2019,
#     'Guardians of the Galaxy': 2014,
#     'Iron Man': 2008,
#     'Thor': 2011
# }

# # Сортування за назвами фільмів (ключами)
# for film in sorted(films):
#     print((film, films[film]))

# # Інший варіант — створити новий словник із відсортованих пар
# sorted_films = dict(sorted(films.items()))
# print(sorted_films)

# # Вивід кожної пари з відсортованого словника
# for name, year in sorted_films.items():
#     print((name, year))

# # створення нового словника, відсортованого за ключами
# sorted_films = dict(sorted(films.items()))

# # можна запитати 
# print(films)
# print(sorted_films)
# print(sorted(films.items()))

# # виведення елементів у форматі ("назва", рік)
# for name, year in sorted_films.items():
#     print(f"('{name}', {year})")  # або такий варіант  print((name, year))

# for name_year in sorted_films.items():
#     print(name_year)



# # ------------------------------------------------------------------------------------------
# # 4.Надрукуйте елементи словника, де ключі - це числа від '1' до 'n' (обидва числа включно), а значення - квадрати ключів. 'n' – ціле число, яке вводить користувача.

# n = int(input("n: "))

# squares = {}  # dict()

# for i in range(1, n + 1):
#     # dict[key] = value
#     squares[i] = i ** 2

# # або коротший варіант через генератор словника
# squares = {i: i ** 2 for i in range(1, n + 1)}

# print(squares)

# # Обидва варіанти роблять те саме — просто другий коротший і продвинутіший.


# # -----------------------------------------------------------------------------------
# # 5.Створіть словник, у якому ключі – назви днів тижня, а значення – ціли числа, що позначають порядковий номер дня тижня від 0 до 6. Надрукуйте назву дня за введеним порядковим номером дня. Якщо введений номер виходить за межі, програма жодних повідомлень не друкує і не повідомляє про помилку.
#   weeks =["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

# week_dict = dict(zip(weeks, range(7)))

# n = int(input("Enter day number (0-6): "))

# # знаходимо день за номером
# for day, num in week_dict.items():
#     if num == n:
#         print(day)
#         break

# #  або інший варіант (продвинутіший), через «зворотний» словник, без циклів:

# week_dict = {i: day for i, day in enumerate(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"])}

# n = int(input("Enter day number (0-6): "))

# print(week_dict.get(n, ""))  # нічого не друкує, якщо немає такого номера



# # --------------------------------------------------------------------------------------------
# # 6.Напишіть програму для створення словника із введеного рядка символів для підрахунку кількості символів

# вхідні дані: 

# Lorem ipsum dolor sit amet 

# Вихідні дані:

# {'L': 1, 'o': 3, 'r': 2, 'e': 2, 'm': 3, ' ': 4, 'i': 2, 'p': 1, 's': 2, 'u': 1, 'd': 1, 'l': 1, 't': 2, 'a': 1}


# text = "Lorem ipsum dolor sit amet"

# # text = list(text)

# letters = {i: text.count(i) for i in text}

# print(letters)

# # Пояснення коротко й по-людськи:

# # for ch in text проходить кожен символ;

# # text.count(ch) рахує, скільки разів цей символ трапляється;

# # у результаті виходить словник з усіма символами і кількістю їх появ;

# # пробіли також враховуються, як у прикладі.

# text = "Lorem ipsum dolor sit amet"   -  це ми створюємо змінну text і записуємо в неї рядок із текстом

# # Це звичайний рядок (тип str) у Python. У ньому є літери, пробіли, і він зберігається як послідовність символів.

# text = list(text)  -  це ми перетворюємо рядок на список окремих символів

# # Функція list() розбиває рядок на список, де кожен елемент — це один символ.
# # Наприклад, буде так:
# # ['L', 'o', 'r', 'e', 'm', ' ', 'i', 'p', 's', 'u', 'm', ' ', 'd', 'o', 'l', 'o', 'r', ' ', 's', 'i', 't', ' ', 'a', 'm', 'e', 't']

# letters = {i: text.count(i) for i in text}   - це ми створюємо словник із кількістю входжень кожного символу
# # наступне:
# # Це словникове включення (dictionary comprehension).
# # Ми перебираємо всі символи `i` у списку `text`.
# # Для кожного символу обчислюємо, скільки разів він зустрічається у всьому списку — функцією text.count(i).
# # Результат має вигляд:
# # {'L': 1, 'o': 3, 'r': 2, 'e': 2, 'm': 3, ' ': 4, 'i': 2, 'p': 1, 's': 2, 'u': 1, 'd': 1, 'l': 1, 't': 2, 'a': 1}

# print(letters)  - цеми виводимо отриманий словник на екран

# # Команда print() друкує значення змінної letters.
# # На екрані отримаємо підрахунок усіх символів:
# # {'L': 1, 'o': 3, 'r': 2, 'e': 2, 'm': 3, ' ': 4, 'i': 2, 'p': 1, 's': 2, 'u': 1, 'd': 1, 'l': 1, 't': 2, 'a': 1}


# # Варіант 2:

# from collections import Counter   - це ми імпортуємо клас Counter для швидкого підрахунку символів
# # Counter автоматично створює словник, де ключ — символ, а значення — кількість його появ.

# text = "Lorem ipsum dolor sit amet"   # Вихідний рядок
# letters = Counter(text)               # Підрахунок символів за один прохід
# print(dict(letters))                  # Виводимо результат у вигляді звичайного словника

# # for key in [1, 2, 3]
#     # d[key] = 0

# # -----------------------------------------------------------------------------------------------
# # 7.Напишіть програму, яка приймає рядок символів ї обчислює кількість букв і цифр.

# Вхідні дані:

# Project Gutenberg offers over 59, 000 free eBooks

# Вихідні дані:

# LETTERS 36
# DIGITS 5

#  # розвязання

# def task7():
#     text = "Project Gutenberg offers over 59, 000 free eBooks"

#     number_count = 0
#     alpha_count = 0

#     for ch in text:
#         if ch.isdigit():
#             number_count += 1
#         elif ch.isalpha():
#             alpha_count += 1

#     result = {
#         "LETTERS": alpha_count,
#         "DIGITS": number_count
#     }

#     for key, value in result.items():
#         print(key, value)

# task7()



# # ------------------------------------------------------------------------------------
# # 8. Напишіть програму для видалення дублікатів зі списком цілих чисел.

# # 1 Через цикл:

# nums = [1, 2, 2, 3, 3, 4]
# unique = []
# for n in nums:
#     if n not in unique:
#         unique.append(n)
# print(unique)

# # 2 Через множину (set) — найкоротше:

# nums = [1, 2, 2, 3, 3, 4]
# print(list(set(nums)))

# # 3 Через dict.fromkeys() — порядок зберігається:

# nums = [1, 2, 2, 3, 3, 4]
# print(list(dict.fromkeys(nums)))

# # 4 Через генератор (варіант для стилю):

# nums = [1, 2, 2, 3, 3, 4]
# unique = []
# [unique.append(x) for x in nums if x not in unique]
# print(unique)




# # --------------------------------------------------------------------------------------
# # 9.Дано список словників. Кожен словник має 2 пари елементів: ключ 'name' і значення імені студента, ключ 'points' і значення - список балів з різних дисциплін (цілі двоцифрові числа). Надрукуйте найменші значення балів, отримані кожним студентом, в один рядок з пропуском.

# #  1 варіан:

# students = [
#     {"name": "Anna", "points": [67, 88, 90]},
#     {"name": "Ivan", "points": [75, 82, 69]},
#     {"name": "Oleh", "points": [91, 73, 84]}
# ]

# for student in students:
#     print(min(student["points"]), end=" ")

# #  2 варіант через генератор (в один рядок):

# students = [
#     {"name": "Anna", "points": [67, 88, 90]},
#     {"name": "Ivan", "points": [75, 82, 69]},
#     {"name": "Oleh", "points": [91, 73, 84]}
# ]

# print(*[min(s["points"]) for s in students])

# #  3 варіант (найкоротший) виводить імена:

# for s in students:
#     print(f"{s['name']}: {min(s['points'])}")



# # -------------------------------------------------------------------------------
# # 10. Дано два списки чисел. Порахуйте, скільки унікальних цифр міститься в обох з ними.

# numbers1 = [1, 5, 3, 8, 8, 1]
# numbers2 = [23, 9, 0, 1, 5]

# result = len(set(numbers1 + numbers2))
# print(numbers1 + numbers2)

# # об,єднання множин
# numbers1 = {1, 5, 3, 8, 8}
# numbers2 = {23, 9, 0, 1, 5}

# # A - B = A (без B)
# # {1, 5, 3, 8, 0} - {23, 9, 0, 1, 5} = {3, 8}
# print(numbers1.difference(numbers2))  # a - b
# print(numbers1 | numbers2)

# # обєднані множини мінус перетин
# # {1, 5, 3, 8, 0} ^ {23, 9, 0, 1, 5} = {3, 23, 8, 9}  
# print(numbers1.symmetric_difference(numbers2))   # a ^ b
# print(numbers1 ^ numbers2)

# # перетин множини (спільні елементи)
# # {1, 5, 3, 8, 0} & {23, 9, 0, 1, 5} = {1, 5}
# print(numbers1.intersection(numbers2)) 
# print(numbers1)
# # print(numbers1 ^ numbers2)

# # або ще так можна, як ВАРІАНТ:

# numbers1 = [1, 5, 3, 8, 8, 1]
# numbers2 = [23, 9, 0, 1, 5]

# # унікальні числа в обох списках
# unique_numbers = set(numbers1 + numbers2)
# print("Об’єднання списків:", numbers1 + numbers2)
# print("Унікальні числа:", unique_numbers)
# print("Кількість унікальних чисел:", len(unique_numbers))




# # -----------------------------------------------------------------------------------
# # 11.Дано три словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа. Ключі у всіх словниках – різні, їх є по 3 в кожному словнику. Об’єднайте всі три словники в один і виведіть його вміст. Підказка. скористайтеся оператором **, що використовується для об’єднання довільної кількості словників.

# # варіант 1 з оператором ** (самий прости):

# dict1 = {'a': 1, 'b': 2, 'c': 3}
# dict2 = {'d': 4, 'e': 5, 'f': 6}
# dict3 = {'g': 7, 'h': 8, 'i': 9}

# merged = {**dict1, **dict2, **dict3}
# print(merged)

# # варіант 2 (через update())

# merged = {}
# merged.update(dict1)
# merged.update(dict2)
# merged.update(dict3)

# print(merged)

# # варіант 3 (новіший спосіб у Python 3.9+) самий короткий

# merged = dict1 | dict2 | dict3
# print(merged)

# # пояснення для себе:
# Якщо ключі повторюються
# dict1 = {'a': 1, 'b': 2, 'c': 3}
# dict2 = {'b': 200, 'd': 4}
# dict3 = {'a': 1000, 'e': 5}

# merged = {**dict1, **dict2, **dict3}
# print(merged)


# Результат:

# {'a': 1000, 'b': 200, 'c': 3, 'd': 4, 'e': 5}

# Що сталося:

# Ключ 'a' був і в dict1, і в dict3.
# Береться останнє значення (1000 з dict3).

# Те саме з 'b' — замінилося на 200 з dict2.

# Python іде зліва направо, тому те, що правіше — важливіше.

# Виходить, що правий словник переписує значення лівого.




# # ---------------------------------------------------------------------------------------------
# # 12.Створіть словник, який відображає ідентифікатори акцій на біржі. Ключами словника є ідентифікатори акцій, а значеннями - дійсні числа - ціни акцій. Надрукуйте ціни акцій та ідентифікатори у порядку зростання ціни.

# Вихідні дані:

# 10.75 FB
# 37.2 HPQ
# 45.23 ACME
# 205.55 IBM
# 612.78 AAPL

# stocks = {
#     "AAPL": 612.78,
#     "IBM": 205.55,
#     "ACME": 45.23,
#     "HPQ": 37.20,
#     "FB": 10.75
# }

# # Сортуємо словник за ціною (значенням)
# for stock, price in sorted(stocks.items(), key=lambda x: x[1]):
#     print(price, stock)

# # пояснення, що відбувається:

# # stocks.items() — повертає пари (ключ, значення);

# # sorted(..., key=lambda x: x[1]) — сортує за другим елементом (тобто ціною);

# # у циклі for ми просто друкуємо все по черзі.

# # # Результат:

# # 10.75 FB  
# # 37.2 HPQ  
# # 45.23 ACME  
# # 205.55 IBM  
# # 612.78 AAPL




# # -----------------------------------------------------------------------------------
# # 13.В рядку записаний текст. Словом вважається послідовність непробільних символів, які йдуть підряд, слова розділені одним або більшим числом пропуском або символами кінця рядка. Для кожного слова з цього тексту підрахуйте, скільки разів воно зустрічалося в цьому тексті раніше.

# Вхідні дані:

# var list set tuple list tuple tuple dict var
# Вихідні дані:

# 0 0 0 0 1 1 2 0 1
# Hard level

# # хід виконання:

# text = "var list set tuple list tuple tuple dict var"

# words = text.split()       # розбиваємо рядок на слова
# seen = {}                  # тут зберігатимемо скільки разів бачили кожне слово
# counts = []                # сюди підемо писати результат

# for word in words:
#     counts.append(seen.get(word, 0))  # додаємо, скільки разів вже бачили це слово
#     seen[word] = seen.get(word, 0) + 1  # збільшуємо лічильник для цього слова

# print(*counts)

# # пояснення:
# # split() розбиває текст на список слів;

# # seen.get(word, 0) — повертає, скільки разів це слово вже зустрічалось (або 0, якщо ще ні);

# # append() додає поточну кількість у список counts;

# # після цього збільшуємо лічильник для цього слова на 1.




# # -------------------------------------------------------------------------------------
# # 14.Напишіть програму, яка зможе підрахувати слова у введеному рядку, розділені пропуском і вивести отриману статистику: для кожного унікального слова обчислити число його повторень (без урахування регістру), слова не повинні повторюватися, порядок слів довільний.

# Вхідні дані:

# a bb acD bb abc ac BCD a
# Вихідні дані:

# a 2
# bb 2
# acd 1
# abc 1
# ac 1
# bcd 1

# #  рішення: 

# text = "a bb acD bb abc ac BCD a"

# words = text.lower().split()          # все в нижній регістр і ділимо по пробілах
# count = {w: words.count(w) for w in set(words)}  # підрахунок унікальних слів

# for word, num in count.items():
#     print(word, num)

# # пояснення:
# # lower() — ігноруємо регістр;

# # split() — розділяємо слова;

# # set(words) — прибираємо дублікати;

# # {w: words.count(w) for w in set(words)} — формуємо словник слово:кількість;

# # потім просто друкуємо.




# # -----------------------------------------------------------------------------------
# # 15.Дано два списки чисел. Знайдіть всі числа, що зустрічаються як в першому, так і другому списках, і надрукуйте їх у порядку зростання.

# Вхідні дані:

# 2 5 8 11 10 9
# 11 3 7 6 8 5
# Вихідні дані:

# 5 8 11

# # вхідні дані
# list1 = [2, 5, 8, 11, 10, 9]
# list2 = [11, 3, 7, 6, 8, 5]

# # перетин множин
# common = sorted(set(list1) & set(list2))

# # виведення результату
# print(*common)

# # пояснення як це працює:

# # set(list1) & set(list2) — знаходить спільні елементи обох списків;

# # sorted() — сортує їх по зростанню;

# # *common — розпаковує список, щоб вивести числа через пробіл.

# # Результат:

# # 5 8 11




# # ------------------------------------------------------------------------------------
# # 16.Напишіть програму, яка вміє шифрувати і розшифровувати використовуючи шифр підстановки. Програма приймає на вхід два рядки однакової довжини, у першому рядку записані символи початкового алфавіту, у другому рядку - символи кінцевого алфавіту (шифр підстановки), після чого йде рядок, який потрібно зашифрувати переданим шифром підстановки, і ще один рядок, який потрібно розшифрувати. Нехай, наприклад, на вхід програми передано:
# abcd
# *d%#
# abacabadaba
# #*%*d*%
# Це означає, що символ a вхідного повідомлення замінюється на символ * в шифрі, b замінюється на d, c - на % і d - на #. Потрібно зашифрувати рядок abacabadaba і розшифрувати рядок #*%*d*% за допомогою цього шифру. Отримуємо наступні рядки, які і передаємо на виведення програми:
# *d*%*d*#*d*
# dacabac
# Вхідні дані:
# abcd
# 1234
# ababcdcd
# 44332211
# Вихідні дані:
# 12123434
# ddccbbaa

# # Вхідні дані
# alphabet = "abcd"
# cipher = "1234"
# to_encrypt = "ababcdcd"
# to_decrypt = "44332211"

# # Створюємо словники для кодування та декодування
# encrypt_dict = dict(zip(alphabet, cipher))
# decrypt_dict = dict(zip(cipher, alphabet))

# # Шифрування
# encrypted = ''.join(encrypt_dict[ch] for ch in to_encrypt)

# # Розшифрування
# decrypted = ''.join(decrypt_dict[ch] for ch in to_decrypt)

# print(encrypted)
# print(decrypted)

# # пояснення як це працює:

# zip(alphabet, cipher) з'єднує символи попарно: a→1, b→2, c→3, d→4.

# dict(...) робить із цього словник для швидкого пошуку.

# join() проходить по кожному символу рядка і підставляє заміну.

# # Результат:

# 12123434
# ddccbbaa